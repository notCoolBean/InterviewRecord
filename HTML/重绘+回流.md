# 重绘+回流

### 一、浏览器渲染流程

<div align="center">
  <img src="../assets/images/dom.png"/>
</div>

1. 解析HTML,生成DOM树；
2. 解析CSS，生成CSSOM树；
3. 将DOM树跟CSSOM树结合，生成渲染树(Render Tree)；
4. Layout(回流)：根据生成的渲染树进行回流，得到节点的几何信息(位置，大小)；
5. Painting(重绘)：根据渲染树以及回流得到的几何信息得到节点的绝对像素；
6. Display：将元素发送给GPU，展示在页面上；

为了构建渲染树，浏览器完成以下工作：

1. 从DOM树的根结点开始遍历每个可见节点；
2. 对于每个可见节点，找到CSSOM树中对应的规则，并应用它们；
3. 根据每个可见节点以及其对应的样式，组合生成渲染树；

第一步中，可见与不可见节点：

- 一些不会渲染输出的节点，比如script、met、link等；
- 一些通过css进行隐藏的节点。比如display：none（脱离文档流）；
注意：使用visibility和opacity隐藏的节点还是会渲染到渲染树上的，只有display：none；才不会渲染到渲染树上；

### 二、回流

> 通过构建渲染树将可见节点以及他们的样式结合起来，然后计算它们在设备视口（viewport）内的确切位置和大小，这个计算的阶段就是 **回流**；

也就是说当页面的布局和几何信息发生变化就会触发回流：

- 元素的位置发生变化；
- 页面一开始渲染的时候；
- 添加或删除可见的DOM元素；
- 浏览器的窗口尺寸发生变化；
- 元素的尺寸发生变化（外边距、内边距、边框大小、高度、宽度）；
- 内容发生变化，比如文本变化或者图片被另一张不同尺寸的图片替换；

**注意：回流一定会触发重绘，但重绘不一定会回流**

### 三、重绘

> 通过构建渲染树和回流阶段，确定了哪些节点是可见的，以及可见节点的样式和具体的几何信息（位置，大小），将渲染树的每个节点都转化为屏幕上的实际像素，这个阶段就叫做**重绘**；

也就是说只影响元素的外观、风格，而不会影响布局和位置信息的操作会触发重绘但不会触发回流；（只改变样式，不改变结构）

**回流比重绘的代价高很多，跟渲染树的节点数量有关系**

### 四、浏览器优化

浏览器会维护一个队列把所有的引起回流跟重绘的操作放入队列中，如果队列中的任务数量超过一定的限制时，浏览器会进行一次批处理然后清空队列，这样就会合并多次的重绘跟回流；

但是当我们调用某些api的时候会触发浏览器立刻清空队列：

- clientWidth、clientHeight、clientTop、clientLeft；
- offsetWidth、offsetHeight、offsetTop、offsetLeft；
- scrollWidth、scrollHeight、scrollTop、scrollLeft；
- scrollIntoView()、scrollIntoViewIfNeeded();
- getComputedStyle();
- getBoundingClientReact();
- scrollTo();

立刻清空队列会导致浏览器的优化失效；

### 五、减少回流跟重绘

#### 最小化回流跟重绘

- 合并多次DOM跟样式修改；
- 批量修改DOM（插入或者修改内容）；
  - 使元素脱离文档流；
    - 隐藏元素，应用修改，重新显示（display：none；）；
    - 使用文档片段（document fragment）在当前DOM之外构建子树，再拷贝回文档；
    - 将原始元素拷贝到一个脱离文档的节点中，修改节点后，在替换原始节点；
  - 对其进行多次修改；
  - 将元素带回到文档中；

> 以上优化方式基本会包含在浏览器优化之中，因为浏览器会一次性处理队列中的操作，减少频繁操作所以以上优化方式不是很明显；

#### 避免触发同步布局事件

上面提到我们在调用DOM的以下API访问元素属性的时候会触发清空队列，致使浏览器优化失效，所以我们这里主动减少这样的触发清空队列的操作就可以了，例如在使用触发清空队列的属性的时候采取缓存避免每次用每次取；

#### 复杂动画使元素脱离文档流，避免反复触发回流重绘

脱离文档流会的元素不会影响频繁触发布局信息，这样就不会频繁的触发页面的重绘跟回流影响页面渲染性能；

#### 使用CSS3的硬件加速（GPU加速）

可以开启硬件加速的CSS3属性：
  - transform
  - opacity；
  - filters；（滤镜）
  - Will-change；（提前告诉浏览器接下来的动作优化浏览器性能）
